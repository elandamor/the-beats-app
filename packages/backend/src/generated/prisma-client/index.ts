// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  album: (where?: AlbumWhereInput) => Promise<boolean>;
  artist: (where?: ArtistWhereInput) => Promise<boolean>;
  audio: (where?: AudioWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  playlist: (where?: PlaylistWhereInput) => Promise<boolean>;
  playlistTrack: (where?: PlaylistTrackWhereInput) => Promise<boolean>;
  track: (where?: TrackWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  album: (where: AlbumWhereUniqueInput) => AlbumNullablePromise;
  albums: (args?: {
    where?: AlbumWhereInput;
    orderBy?: AlbumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Album>;
  albumsConnection: (args?: {
    where?: AlbumWhereInput;
    orderBy?: AlbumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AlbumConnectionPromise;
  artist: (where: ArtistWhereUniqueInput) => ArtistNullablePromise;
  artists: (args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Artist>;
  artistsConnection: (args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ArtistConnectionPromise;
  audio: (where: AudioWhereUniqueInput) => AudioNullablePromise;
  audios: (args?: {
    where?: AudioWhereInput;
    orderBy?: AudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Audio>;
  audiosConnection: (args?: {
    where?: AudioWhereInput;
    orderBy?: AudioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AudioConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  playlist: (where: PlaylistWhereUniqueInput) => PlaylistNullablePromise;
  playlists: (args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Playlist>;
  playlistsConnection: (args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaylistConnectionPromise;
  playlistTrack: (
    where: PlaylistTrackWhereUniqueInput
  ) => PlaylistTrackNullablePromise;
  playlistTracks: (args?: {
    where?: PlaylistTrackWhereInput;
    orderBy?: PlaylistTrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlaylistTrack>;
  playlistTracksConnection: (args?: {
    where?: PlaylistTrackWhereInput;
    orderBy?: PlaylistTrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlaylistTrackConnectionPromise;
  track: (where: TrackWhereUniqueInput) => TrackNullablePromise;
  tracks: (args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Track>;
  tracksConnection: (args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrackConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAlbum: (data: AlbumCreateInput) => AlbumPromise;
  updateAlbum: (args: {
    data: AlbumUpdateInput;
    where: AlbumWhereUniqueInput;
  }) => AlbumPromise;
  updateManyAlbums: (args: {
    data: AlbumUpdateManyMutationInput;
    where?: AlbumWhereInput;
  }) => BatchPayloadPromise;
  upsertAlbum: (args: {
    where: AlbumWhereUniqueInput;
    create: AlbumCreateInput;
    update: AlbumUpdateInput;
  }) => AlbumPromise;
  deleteAlbum: (where: AlbumWhereUniqueInput) => AlbumPromise;
  deleteManyAlbums: (where?: AlbumWhereInput) => BatchPayloadPromise;
  createArtist: (data: ArtistCreateInput) => ArtistPromise;
  updateArtist: (args: {
    data: ArtistUpdateInput;
    where: ArtistWhereUniqueInput;
  }) => ArtistPromise;
  updateManyArtists: (args: {
    data: ArtistUpdateManyMutationInput;
    where?: ArtistWhereInput;
  }) => BatchPayloadPromise;
  upsertArtist: (args: {
    where: ArtistWhereUniqueInput;
    create: ArtistCreateInput;
    update: ArtistUpdateInput;
  }) => ArtistPromise;
  deleteArtist: (where: ArtistWhereUniqueInput) => ArtistPromise;
  deleteManyArtists: (where?: ArtistWhereInput) => BatchPayloadPromise;
  createAudio: (data: AudioCreateInput) => AudioPromise;
  updateAudio: (args: {
    data: AudioUpdateInput;
    where: AudioWhereUniqueInput;
  }) => AudioPromise;
  updateManyAudios: (args: {
    data: AudioUpdateManyMutationInput;
    where?: AudioWhereInput;
  }) => BatchPayloadPromise;
  upsertAudio: (args: {
    where: AudioWhereUniqueInput;
    create: AudioCreateInput;
    update: AudioUpdateInput;
  }) => AudioPromise;
  deleteAudio: (where: AudioWhereUniqueInput) => AudioPromise;
  deleteManyAudios: (where?: AudioWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createPlaylist: (data: PlaylistCreateInput) => PlaylistPromise;
  updatePlaylist: (args: {
    data: PlaylistUpdateInput;
    where: PlaylistWhereUniqueInput;
  }) => PlaylistPromise;
  updateManyPlaylists: (args: {
    data: PlaylistUpdateManyMutationInput;
    where?: PlaylistWhereInput;
  }) => BatchPayloadPromise;
  upsertPlaylist: (args: {
    where: PlaylistWhereUniqueInput;
    create: PlaylistCreateInput;
    update: PlaylistUpdateInput;
  }) => PlaylistPromise;
  deletePlaylist: (where: PlaylistWhereUniqueInput) => PlaylistPromise;
  deleteManyPlaylists: (where?: PlaylistWhereInput) => BatchPayloadPromise;
  createPlaylistTrack: (data: PlaylistTrackCreateInput) => PlaylistTrackPromise;
  updatePlaylistTrack: (args: {
    data: PlaylistTrackUpdateInput;
    where: PlaylistTrackWhereUniqueInput;
  }) => PlaylistTrackPromise;
  updateManyPlaylistTracks: (args: {
    data: PlaylistTrackUpdateManyMutationInput;
    where?: PlaylistTrackWhereInput;
  }) => BatchPayloadPromise;
  upsertPlaylistTrack: (args: {
    where: PlaylistTrackWhereUniqueInput;
    create: PlaylistTrackCreateInput;
    update: PlaylistTrackUpdateInput;
  }) => PlaylistTrackPromise;
  deletePlaylistTrack: (
    where: PlaylistTrackWhereUniqueInput
  ) => PlaylistTrackPromise;
  deleteManyPlaylistTracks: (
    where?: PlaylistTrackWhereInput
  ) => BatchPayloadPromise;
  createTrack: (data: TrackCreateInput) => TrackPromise;
  updateTrack: (args: {
    data: TrackUpdateInput;
    where: TrackWhereUniqueInput;
  }) => TrackPromise;
  updateManyTracks: (args: {
    data: TrackUpdateManyMutationInput;
    where?: TrackWhereInput;
  }) => BatchPayloadPromise;
  upsertTrack: (args: {
    where: TrackWhereUniqueInput;
    create: TrackCreateInput;
    update: TrackUpdateInput;
  }) => TrackPromise;
  deleteTrack: (where: TrackWhereUniqueInput) => TrackPromise;
  deleteManyTracks: (where?: TrackWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  album: (
    where?: AlbumSubscriptionWhereInput
  ) => AlbumSubscriptionPayloadSubscription;
  artist: (
    where?: ArtistSubscriptionWhereInput
  ) => ArtistSubscriptionPayloadSubscription;
  audio: (
    where?: AudioSubscriptionWhereInput
  ) => AudioSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  playlist: (
    where?: PlaylistSubscriptionWhereInput
  ) => PlaylistSubscriptionPayloadSubscription;
  playlistTrack: (
    where?: PlaylistTrackSubscriptionWhereInput
  ) => PlaylistTrackSubscriptionPayloadSubscription;
  track: (
    where?: TrackSubscriptionWhereInput
  ) => TrackSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ReleaseType = "ALBUM" | "EP" | "LP" | "PODCAST" | "SINGLE";

export type Privacy = "PRIVATE" | "PUBLIC" | "UNLISTED";

export type ArtistOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "alias_ASC"
  | "alias_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AlbumOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "alias_ASC"
  | "alias_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "name_ASC"
  | "name_DESC"
  | "numTracks_ASC"
  | "numTracks_DESC"
  | "releaseDate_ASC"
  | "releaseDate_DESC"
  | "releaseType_ASC"
  | "releaseType_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlaylistOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "alias_ASC"
  | "alias_DESC"
  | "collaborative_ASC"
  | "collaborative_DESC"
  | "description_ASC"
  | "description_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "name_ASC"
  | "name_DESC"
  | "numTracks_ASC"
  | "numTracks_DESC"
  | "privacy_ASC"
  | "privacy_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PlaylistTrackOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "addedAt_ASC"
  | "addedAt_DESC";

export type TrackOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "discNumber_ASC"
  | "discNumber_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "explicit_ASC"
  | "explicit_DESC"
  | "genre_ASC"
  | "genre_DESC"
  | "isPlayable_ASC"
  | "isPlayable_DESC"
  | "name_ASC"
  | "name_DESC"
  | "trackNumber_ASC"
  | "trackNumber_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AudioOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "bitrate_ASC"
  | "bitrate_DESC"
  | "format_ASC"
  | "format_DESC"
  | "size_ASC"
  | "size_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isAdmin_ASC"
  | "isAdmin_DESC"
  | "name_ASC"
  | "name_DESC"
  | "username_ASC"
  | "username_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface PlaylistTrackUpdateManyWithoutPlaylistsInput {
  create?: Maybe<
    | PlaylistTrackCreateWithoutPlaylistsInput[]
    | PlaylistTrackCreateWithoutPlaylistsInput
  >;
  delete?: Maybe<
    PlaylistTrackWhereUniqueInput[] | PlaylistTrackWhereUniqueInput
  >;
  connect?: Maybe<
    PlaylistTrackWhereUniqueInput[] | PlaylistTrackWhereUniqueInput
  >;
  set?: Maybe<PlaylistTrackWhereUniqueInput[] | PlaylistTrackWhereUniqueInput>;
  disconnect?: Maybe<
    PlaylistTrackWhereUniqueInput[] | PlaylistTrackWhereUniqueInput
  >;
  update?: Maybe<
    | PlaylistTrackUpdateWithWhereUniqueWithoutPlaylistsInput[]
    | PlaylistTrackUpdateWithWhereUniqueWithoutPlaylistsInput
  >;
  upsert?: Maybe<
    | PlaylistTrackUpsertWithWhereUniqueWithoutPlaylistsInput[]
    | PlaylistTrackUpsertWithWhereUniqueWithoutPlaylistsInput
  >;
  deleteMany?: Maybe<
    PlaylistTrackScalarWhereInput[] | PlaylistTrackScalarWhereInput
  >;
  updateMany?: Maybe<
    | PlaylistTrackUpdateManyWithWhereNestedInput[]
    | PlaylistTrackUpdateManyWithWhereNestedInput
  >;
}

export type AlbumWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  alias?: Maybe<String>;
}>;

export interface TrackCreateManyWithoutArtistsInput {
  create?: Maybe<
    TrackCreateWithoutArtistsInput[] | TrackCreateWithoutArtistsInput
  >;
  connect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
}

export interface AlbumUpdateManyMutationInput {
  alias?: Maybe<String>;
  duration?: Maybe<Int>;
  genres?: Maybe<AlbumUpdategenresInput>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  releaseDate?: Maybe<DateTimeInput>;
  releaseType?: Maybe<ReleaseType>;
}

export interface TrackCreateWithoutArtistsInput {
  id?: Maybe<ID_Input>;
  album: AlbumCreateOneWithoutTracksInput;
  audio?: Maybe<AudioCreateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  featuring?: Maybe<ArtistCreateManyWithoutFeaturesInInput>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name: String;
  trackNumber: Int;
}

export interface AlbumUpdateWithoutTracksDataInput {
  alias?: Maybe<String>;
  artists?: Maybe<ArtistUpdateManyWithoutAlbumsInput>;
  duration?: Maybe<Int>;
  genres?: Maybe<AlbumUpdategenresInput>;
  artwork?: Maybe<ImageUpdateOneInput>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  releaseDate?: Maybe<DateTimeInput>;
  releaseType?: Maybe<ReleaseType>;
  addedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface TrackCreateManyWithoutFeaturingInput {
  create?: Maybe<
    TrackCreateWithoutFeaturingInput[] | TrackCreateWithoutFeaturingInput
  >;
  connect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
}

export interface PlaylistTrackWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  addedAt?: Maybe<DateTimeInput>;
  addedAt_not?: Maybe<DateTimeInput>;
  addedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  addedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  addedAt_lt?: Maybe<DateTimeInput>;
  addedAt_lte?: Maybe<DateTimeInput>;
  addedAt_gt?: Maybe<DateTimeInput>;
  addedAt_gte?: Maybe<DateTimeInput>;
  addedBy?: Maybe<UserWhereInput>;
  playlists_every?: Maybe<PlaylistWhereInput>;
  playlists_some?: Maybe<PlaylistWhereInput>;
  playlists_none?: Maybe<PlaylistWhereInput>;
  track?: Maybe<TrackWhereInput>;
  AND?: Maybe<PlaylistTrackWhereInput[] | PlaylistTrackWhereInput>;
  OR?: Maybe<PlaylistTrackWhereInput[] | PlaylistTrackWhereInput>;
  NOT?: Maybe<PlaylistTrackWhereInput[] | PlaylistTrackWhereInput>;
}

export interface TrackCreateWithoutFeaturingInput {
  id?: Maybe<ID_Input>;
  album: AlbumCreateOneWithoutTracksInput;
  artists?: Maybe<ArtistCreateManyWithoutTracksInput>;
  audio?: Maybe<AudioCreateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name: String;
  trackNumber: Int;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface AlbumUpdateInput {
  alias?: Maybe<String>;
  artists?: Maybe<ArtistUpdateManyWithoutAlbumsInput>;
  duration?: Maybe<Int>;
  genres?: Maybe<AlbumUpdategenresInput>;
  artwork?: Maybe<ImageUpdateOneInput>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  releaseDate?: Maybe<DateTimeInput>;
  releaseType?: Maybe<ReleaseType>;
  tracks?: Maybe<TrackUpdateManyWithoutAlbumInput>;
  addedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface PlaylistTrackSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaylistTrackWhereInput>;
  AND?: Maybe<
    PlaylistTrackSubscriptionWhereInput[] | PlaylistTrackSubscriptionWhereInput
  >;
  OR?: Maybe<
    PlaylistTrackSubscriptionWhereInput[] | PlaylistTrackSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PlaylistTrackSubscriptionWhereInput[] | PlaylistTrackSubscriptionWhereInput
  >;
}

export interface ArtistUpdateManyWithoutAlbumsInput {
  create?: Maybe<
    ArtistCreateWithoutAlbumsInput[] | ArtistCreateWithoutAlbumsInput
  >;
  delete?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  connect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  set?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  disconnect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  update?: Maybe<
    | ArtistUpdateWithWhereUniqueWithoutAlbumsInput[]
    | ArtistUpdateWithWhereUniqueWithoutAlbumsInput
  >;
  upsert?: Maybe<
    | ArtistUpsertWithWhereUniqueWithoutAlbumsInput[]
    | ArtistUpsertWithWhereUniqueWithoutAlbumsInput
  >;
  deleteMany?: Maybe<ArtistScalarWhereInput[] | ArtistScalarWhereInput>;
  updateMany?: Maybe<
    | ArtistUpdateManyWithWhereNestedInput[]
    | ArtistUpdateManyWithWhereNestedInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  isAdmin?: Maybe<Boolean>;
  isAdmin_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  playlists_every?: Maybe<PlaylistWhereInput>;
  playlists_some?: Maybe<PlaylistWhereInput>;
  playlists_none?: Maybe<PlaylistWhereInput>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ArtistUpdateWithWhereUniqueWithoutAlbumsInput {
  where: ArtistWhereUniqueInput;
  data: ArtistUpdateWithoutAlbumsDataInput;
}

export interface ImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  uploadedBy?: Maybe<UserWhereInput>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  OR?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  NOT?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface ArtistUpdateWithoutAlbumsDataInput {
  alias?: Maybe<String>;
  avatar?: Maybe<ImageUpdateOneInput>;
  featuresIn?: Maybe<TrackUpdateManyWithoutFeaturingInput>;
  genres?: Maybe<ArtistUpdategenresInput>;
  name?: Maybe<String>;
  tracks?: Maybe<TrackUpdateManyWithoutArtistsInput>;
}

export interface ArtistSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ArtistWhereInput>;
  AND?: Maybe<ArtistSubscriptionWhereInput[] | ArtistSubscriptionWhereInput>;
  OR?: Maybe<ArtistSubscriptionWhereInput[] | ArtistSubscriptionWhereInput>;
  NOT?: Maybe<ArtistSubscriptionWhereInput[] | ArtistSubscriptionWhereInput>;
}

export interface ImageUpdateOneInput {
  create?: Maybe<ImageCreateInput>;
  update?: Maybe<ImageUpdateDataInput>;
  upsert?: Maybe<ImageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface UserUpdateManyMutationInput {
  isAdmin?: Maybe<Boolean>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  username?: Maybe<String>;
  verified?: Maybe<Boolean>;
}

export interface ImageUpdateDataInput {
  uploadedBy?: Maybe<UserUpdateOneRequiredInput>;
  url?: Maybe<String>;
}

export interface UserUpdateInput {
  isAdmin?: Maybe<Boolean>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  playlists?: Maybe<PlaylistUpdateManyWithoutCreatorInput>;
  username?: Maybe<String>;
  verified?: Maybe<Boolean>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TrackUpdateInput {
  album?: Maybe<AlbumUpdateOneRequiredWithoutTracksInput>;
  artists?: Maybe<ArtistUpdateManyWithoutTracksInput>;
  audio?: Maybe<AudioUpdateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  featuring?: Maybe<ArtistUpdateManyWithoutFeaturesInInput>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name?: Maybe<String>;
  trackNumber?: Maybe<Int>;
}

export interface UserUpdateDataInput {
  isAdmin?: Maybe<Boolean>;
  name?: Maybe<String>;
  playlists?: Maybe<PlaylistUpdateManyWithoutCreatorInput>;
  username?: Maybe<String>;
  verified?: Maybe<Boolean>;
}

export type ArtistWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  alias?: Maybe<String>;
}>;

export interface PlaylistUpdateManyWithoutCreatorInput {
  create?: Maybe<
    PlaylistCreateWithoutCreatorInput[] | PlaylistCreateWithoutCreatorInput
  >;
  delete?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
  connect?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
  set?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
  disconnect?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
  update?: Maybe<
    | PlaylistUpdateWithWhereUniqueWithoutCreatorInput[]
    | PlaylistUpdateWithWhereUniqueWithoutCreatorInput
  >;
  upsert?: Maybe<
    | PlaylistUpsertWithWhereUniqueWithoutCreatorInput[]
    | PlaylistUpsertWithWhereUniqueWithoutCreatorInput
  >;
  deleteMany?: Maybe<PlaylistScalarWhereInput[] | PlaylistScalarWhereInput>;
  updateMany?: Maybe<
    | PlaylistUpdateManyWithWhereNestedInput[]
    | PlaylistUpdateManyWithWhereNestedInput
  >;
}

export interface PlaylistUpdateWithoutTracksDataInput {
  alias?: Maybe<String>;
  artwork?: Maybe<ImageUpdateManyInput>;
  collaborative?: Maybe<Boolean>;
  creator?: Maybe<UserUpdateOneRequiredWithoutPlaylistsInput>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  privacy?: Maybe<Privacy>;
}

export interface PlaylistUpdateWithWhereUniqueWithoutCreatorInput {
  where: PlaylistWhereUniqueInput;
  data: PlaylistUpdateWithoutCreatorDataInput;
}

export type AudioWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PlaylistUpdateWithoutCreatorDataInput {
  alias?: Maybe<String>;
  artwork?: Maybe<ImageUpdateManyInput>;
  collaborative?: Maybe<Boolean>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  privacy?: Maybe<Privacy>;
  tracks?: Maybe<PlaylistTrackUpdateManyWithoutPlaylistsInput>;
}

export interface PlaylistUpdateManyWithoutTracksInput {
  create?: Maybe<
    PlaylistCreateWithoutTracksInput[] | PlaylistCreateWithoutTracksInput
  >;
  delete?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
  connect?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
  set?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
  disconnect?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
  update?: Maybe<
    | PlaylistUpdateWithWhereUniqueWithoutTracksInput[]
    | PlaylistUpdateWithWhereUniqueWithoutTracksInput
  >;
  upsert?: Maybe<
    | PlaylistUpsertWithWhereUniqueWithoutTracksInput[]
    | PlaylistUpsertWithWhereUniqueWithoutTracksInput
  >;
  deleteMany?: Maybe<PlaylistScalarWhereInput[] | PlaylistScalarWhereInput>;
  updateMany?: Maybe<
    | PlaylistUpdateManyWithWhereNestedInput[]
    | PlaylistUpdateManyWithWhereNestedInput
  >;
}

export interface ImageUpdateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  update?: Maybe<
    | ImageUpdateWithWhereUniqueNestedInput[]
    | ImageUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ImageUpsertWithWhereUniqueNestedInput[]
    | ImageUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  set?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  disconnect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  deleteMany?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  updateMany?: Maybe<
    ImageUpdateManyWithWhereNestedInput[] | ImageUpdateManyWithWhereNestedInput
  >;
}

export interface PlaylistCreateWithoutTracksInput {
  id?: Maybe<ID_Input>;
  alias: String;
  artwork?: Maybe<ImageCreateManyInput>;
  collaborative?: Maybe<Boolean>;
  creator: UserCreateOneWithoutPlaylistsInput;
  description?: Maybe<String>;
  duration: Int;
  name: String;
  numTracks: Int;
  privacy?: Maybe<Privacy>;
}

export interface ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateDataInput;
}

export interface PlaylistCreateManyWithoutTracksInput {
  create?: Maybe<
    PlaylistCreateWithoutTracksInput[] | PlaylistCreateWithoutTracksInput
  >;
  connect?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
}

export interface ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface PlaylistUpdateManyMutationInput {
  alias?: Maybe<String>;
  collaborative?: Maybe<Boolean>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  privacy?: Maybe<Privacy>;
}

export interface ImageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  OR?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  NOT?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
}

export interface UserUpsertWithoutPlaylistsInput {
  update: UserUpdateWithoutPlaylistsDataInput;
  create: UserCreateWithoutPlaylistsInput;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface UserUpdateOneRequiredWithoutPlaylistsInput {
  create?: Maybe<UserCreateWithoutPlaylistsInput>;
  update?: Maybe<UserUpdateWithoutPlaylistsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPlaylistsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ImageUpdateManyDataInput {
  url?: Maybe<String>;
}

export interface PlaylistUpdateInput {
  alias?: Maybe<String>;
  artwork?: Maybe<ImageUpdateManyInput>;
  collaborative?: Maybe<Boolean>;
  creator?: Maybe<UserUpdateOneRequiredWithoutPlaylistsInput>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  privacy?: Maybe<Privacy>;
  tracks?: Maybe<PlaylistTrackUpdateManyWithoutPlaylistsInput>;
}

export interface ArtistCreateInput {
  id?: Maybe<ID_Input>;
  albums?: Maybe<AlbumCreateManyWithoutArtistsInput>;
  alias: String;
  avatar?: Maybe<ImageCreateOneInput>;
  featuresIn?: Maybe<TrackCreateManyWithoutFeaturingInput>;
  genres?: Maybe<ArtistCreategenresInput>;
  name: String;
  tracks?: Maybe<TrackCreateManyWithoutArtistsInput>;
}

export interface UserCreateOneWithoutPlaylistsInput {
  create?: Maybe<UserCreateWithoutPlaylistsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PlaylistTrackUpdateWithWhereUniqueWithoutPlaylistsInput {
  where: PlaylistTrackWhereUniqueInput;
  data: PlaylistTrackUpdateWithoutPlaylistsDataInput;
}

export interface PlaylistCreateInput {
  id?: Maybe<ID_Input>;
  alias: String;
  artwork?: Maybe<ImageCreateManyInput>;
  collaborative?: Maybe<Boolean>;
  creator: UserCreateOneWithoutPlaylistsInput;
  description?: Maybe<String>;
  duration: Int;
  name: String;
  numTracks: Int;
  privacy?: Maybe<Privacy>;
  tracks?: Maybe<PlaylistTrackCreateManyWithoutPlaylistsInput>;
}

export interface PlaylistTrackUpdateWithoutPlaylistsDataInput {
  addedAt?: Maybe<DateTimeInput>;
  addedBy?: Maybe<UserUpdateOneRequiredInput>;
  track?: Maybe<TrackUpdateOneRequiredInput>;
}

export interface ImageUpdateInput {
  uploadedBy?: Maybe<UserUpdateOneRequiredInput>;
  url?: Maybe<String>;
}

export interface TrackUpdateOneRequiredInput {
  create?: Maybe<TrackCreateInput>;
  update?: Maybe<TrackUpdateDataInput>;
  upsert?: Maybe<TrackUpsertNestedInput>;
  connect?: Maybe<TrackWhereUniqueInput>;
}

export interface AudioUpdateManyMutationInput {
  bitrate?: Maybe<Int>;
  format?: Maybe<String>;
  size?: Maybe<Int>;
  url?: Maybe<String>;
}

export interface TrackUpdateDataInput {
  album?: Maybe<AlbumUpdateOneRequiredWithoutTracksInput>;
  artists?: Maybe<ArtistUpdateManyWithoutTracksInput>;
  audio?: Maybe<AudioUpdateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  featuring?: Maybe<ArtistUpdateManyWithoutFeaturesInInput>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name?: Maybe<String>;
  trackNumber?: Maybe<Int>;
}

export interface ArtistUpdateManyMutationInput {
  alias?: Maybe<String>;
  genres?: Maybe<ArtistUpdategenresInput>;
  name?: Maybe<String>;
}

export interface AlbumUpdateOneRequiredWithoutTracksInput {
  create?: Maybe<AlbumCreateWithoutTracksInput>;
  update?: Maybe<AlbumUpdateWithoutTracksDataInput>;
  upsert?: Maybe<AlbumUpsertWithoutTracksInput>;
  connect?: Maybe<AlbumWhereUniqueInput>;
}

export interface ArtistCreateManyWithoutAlbumsInput {
  create?: Maybe<
    ArtistCreateWithoutAlbumsInput[] | ArtistCreateWithoutAlbumsInput
  >;
  connect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
}

export interface TrackWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  album?: Maybe<AlbumWhereInput>;
  artists_every?: Maybe<ArtistWhereInput>;
  artists_some?: Maybe<ArtistWhereInput>;
  artists_none?: Maybe<ArtistWhereInput>;
  audio?: Maybe<AudioWhereInput>;
  discNumber?: Maybe<Int>;
  discNumber_not?: Maybe<Int>;
  discNumber_in?: Maybe<Int[] | Int>;
  discNumber_not_in?: Maybe<Int[] | Int>;
  discNumber_lt?: Maybe<Int>;
  discNumber_lte?: Maybe<Int>;
  discNumber_gt?: Maybe<Int>;
  discNumber_gte?: Maybe<Int>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  explicit_not?: Maybe<Boolean>;
  featuring_every?: Maybe<ArtistWhereInput>;
  featuring_some?: Maybe<ArtistWhereInput>;
  featuring_none?: Maybe<ArtistWhereInput>;
  genre?: Maybe<String>;
  genre_not?: Maybe<String>;
  genre_in?: Maybe<String[] | String>;
  genre_not_in?: Maybe<String[] | String>;
  genre_lt?: Maybe<String>;
  genre_lte?: Maybe<String>;
  genre_gt?: Maybe<String>;
  genre_gte?: Maybe<String>;
  genre_contains?: Maybe<String>;
  genre_not_contains?: Maybe<String>;
  genre_starts_with?: Maybe<String>;
  genre_not_starts_with?: Maybe<String>;
  genre_ends_with?: Maybe<String>;
  genre_not_ends_with?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  isPlayable_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  trackNumber?: Maybe<Int>;
  trackNumber_not?: Maybe<Int>;
  trackNumber_in?: Maybe<Int[] | Int>;
  trackNumber_not_in?: Maybe<Int[] | Int>;
  trackNumber_lt?: Maybe<Int>;
  trackNumber_lte?: Maybe<Int>;
  trackNumber_gt?: Maybe<Int>;
  trackNumber_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TrackWhereInput[] | TrackWhereInput>;
  OR?: Maybe<TrackWhereInput[] | TrackWhereInput>;
  NOT?: Maybe<TrackWhereInput[] | TrackWhereInput>;
}

export interface ImageCreateOneInput {
  create?: Maybe<ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface AlbumUpdategenresInput {
  set?: Maybe<String[] | String>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface AlbumUpsertWithoutTracksInput {
  update: AlbumUpdateWithoutTracksDataInput;
  create: AlbumCreateWithoutTracksInput;
}

export interface PlaylistCreateManyWithoutCreatorInput {
  create?: Maybe<
    PlaylistCreateWithoutCreatorInput[] | PlaylistCreateWithoutCreatorInput
  >;
  connect?: Maybe<PlaylistWhereUniqueInput[] | PlaylistWhereUniqueInput>;
}

export interface ArtistUpdateManyWithoutTracksInput {
  create?: Maybe<
    ArtistCreateWithoutTracksInput[] | ArtistCreateWithoutTracksInput
  >;
  delete?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  connect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  set?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  disconnect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  update?: Maybe<
    | ArtistUpdateWithWhereUniqueWithoutTracksInput[]
    | ArtistUpdateWithWhereUniqueWithoutTracksInput
  >;
  upsert?: Maybe<
    | ArtistUpsertWithWhereUniqueWithoutTracksInput[]
    | ArtistUpsertWithWhereUniqueWithoutTracksInput
  >;
  deleteMany?: Maybe<ArtistScalarWhereInput[] | ArtistScalarWhereInput>;
  updateMany?: Maybe<
    | ArtistUpdateManyWithWhereNestedInput[]
    | ArtistUpdateManyWithWhereNestedInput
  >;
}

export interface ImageCreateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
}

export interface ArtistUpdateWithWhereUniqueWithoutTracksInput {
  where: ArtistWhereUniqueInput;
  data: ArtistUpdateWithoutTracksDataInput;
}

export interface PlaylistTrackCreateWithoutPlaylistsInput {
  id?: Maybe<ID_Input>;
  addedAt: DateTimeInput;
  addedBy: UserCreateOneInput;
  track: TrackCreateOneInput;
}

export interface ArtistUpdateWithoutTracksDataInput {
  albums?: Maybe<AlbumUpdateManyWithoutArtistsInput>;
  alias?: Maybe<String>;
  avatar?: Maybe<ImageUpdateOneInput>;
  featuresIn?: Maybe<TrackUpdateManyWithoutFeaturingInput>;
  genres?: Maybe<ArtistUpdategenresInput>;
  name?: Maybe<String>;
}

export interface TrackCreateInput {
  id?: Maybe<ID_Input>;
  album: AlbumCreateOneWithoutTracksInput;
  artists?: Maybe<ArtistCreateManyWithoutTracksInput>;
  audio?: Maybe<AudioCreateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  featuring?: Maybe<ArtistCreateManyWithoutFeaturesInInput>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name: String;
  trackNumber: Int;
}

export interface AlbumUpdateManyWithoutArtistsInput {
  create?: Maybe<
    AlbumCreateWithoutArtistsInput[] | AlbumCreateWithoutArtistsInput
  >;
  delete?: Maybe<AlbumWhereUniqueInput[] | AlbumWhereUniqueInput>;
  connect?: Maybe<AlbumWhereUniqueInput[] | AlbumWhereUniqueInput>;
  set?: Maybe<AlbumWhereUniqueInput[] | AlbumWhereUniqueInput>;
  disconnect?: Maybe<AlbumWhereUniqueInput[] | AlbumWhereUniqueInput>;
  update?: Maybe<
    | AlbumUpdateWithWhereUniqueWithoutArtistsInput[]
    | AlbumUpdateWithWhereUniqueWithoutArtistsInput
  >;
  upsert?: Maybe<
    | AlbumUpsertWithWhereUniqueWithoutArtistsInput[]
    | AlbumUpsertWithWhereUniqueWithoutArtistsInput
  >;
  deleteMany?: Maybe<AlbumScalarWhereInput[] | AlbumScalarWhereInput>;
  updateMany?: Maybe<
    AlbumUpdateManyWithWhereNestedInput[] | AlbumUpdateManyWithWhereNestedInput
  >;
}

export interface AlbumCreateWithoutTracksInput {
  id?: Maybe<ID_Input>;
  alias: String;
  artists?: Maybe<ArtistCreateManyWithoutAlbumsInput>;
  duration?: Maybe<Int>;
  genres?: Maybe<AlbumCreategenresInput>;
  artwork?: Maybe<ImageCreateOneInput>;
  name: String;
  numTracks?: Maybe<Int>;
  releaseDate: DateTimeInput;
  releaseType: ReleaseType;
  addedBy: UserCreateOneInput;
}

export interface AlbumUpdateWithWhereUniqueWithoutArtistsInput {
  where: AlbumWhereUniqueInput;
  data: AlbumUpdateWithoutArtistsDataInput;
}

export interface ArtistCreateManyWithoutTracksInput {
  create?: Maybe<
    ArtistCreateWithoutTracksInput[] | ArtistCreateWithoutTracksInput
  >;
  connect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
}

export interface AlbumUpdateWithoutArtistsDataInput {
  alias?: Maybe<String>;
  duration?: Maybe<Int>;
  genres?: Maybe<AlbumUpdategenresInput>;
  artwork?: Maybe<ImageUpdateOneInput>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  releaseDate?: Maybe<DateTimeInput>;
  releaseType?: Maybe<ReleaseType>;
  tracks?: Maybe<TrackUpdateManyWithoutAlbumInput>;
  addedBy?: Maybe<UserUpdateOneRequiredInput>;
}

export interface AlbumCreateManyWithoutArtistsInput {
  create?: Maybe<
    AlbumCreateWithoutArtistsInput[] | AlbumCreateWithoutArtistsInput
  >;
  connect?: Maybe<AlbumWhereUniqueInput[] | AlbumWhereUniqueInput>;
}

export interface TrackUpdateManyWithoutAlbumInput {
  create?: Maybe<TrackCreateWithoutAlbumInput[] | TrackCreateWithoutAlbumInput>;
  delete?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  connect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  set?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  disconnect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  update?: Maybe<
    | TrackUpdateWithWhereUniqueWithoutAlbumInput[]
    | TrackUpdateWithWhereUniqueWithoutAlbumInput
  >;
  upsert?: Maybe<
    | TrackUpsertWithWhereUniqueWithoutAlbumInput[]
    | TrackUpsertWithWhereUniqueWithoutAlbumInput
  >;
  deleteMany?: Maybe<TrackScalarWhereInput[] | TrackScalarWhereInput>;
  updateMany?: Maybe<
    TrackUpdateManyWithWhereNestedInput[] | TrackUpdateManyWithWhereNestedInput
  >;
}

export interface TrackCreateManyWithoutAlbumInput {
  create?: Maybe<TrackCreateWithoutAlbumInput[] | TrackCreateWithoutAlbumInput>;
  connect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
}

export interface TrackUpdateWithWhereUniqueWithoutAlbumInput {
  where: TrackWhereUniqueInput;
  data: TrackUpdateWithoutAlbumDataInput;
}

export interface AudioCreateOneInput {
  create?: Maybe<AudioCreateInput>;
  connect?: Maybe<AudioWhereUniqueInput>;
}

export interface TrackUpdateWithoutAlbumDataInput {
  artists?: Maybe<ArtistUpdateManyWithoutTracksInput>;
  audio?: Maybe<AudioUpdateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  featuring?: Maybe<ArtistUpdateManyWithoutFeaturesInInput>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name?: Maybe<String>;
  trackNumber?: Maybe<Int>;
}

export interface ArtistCreateManyWithoutFeaturesInInput {
  create?: Maybe<
    ArtistCreateWithoutFeaturesInInput[] | ArtistCreateWithoutFeaturesInInput
  >;
  connect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
}

export interface AudioUpdateOneInput {
  create?: Maybe<AudioCreateInput>;
  update?: Maybe<AudioUpdateDataInput>;
  upsert?: Maybe<AudioUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AudioWhereUniqueInput>;
}

export interface ArtistCreategenresInput {
  set?: Maybe<String[] | String>;
}

export interface AudioUpdateDataInput {
  bitrate?: Maybe<Int>;
  format?: Maybe<String>;
  size?: Maybe<Int>;
  uploadedBy?: Maybe<UserUpdateOneRequiredInput>;
  url?: Maybe<String>;
}

export interface PlaylistWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  alias?: Maybe<String>;
  alias_not?: Maybe<String>;
  alias_in?: Maybe<String[] | String>;
  alias_not_in?: Maybe<String[] | String>;
  alias_lt?: Maybe<String>;
  alias_lte?: Maybe<String>;
  alias_gt?: Maybe<String>;
  alias_gte?: Maybe<String>;
  alias_contains?: Maybe<String>;
  alias_not_contains?: Maybe<String>;
  alias_starts_with?: Maybe<String>;
  alias_not_starts_with?: Maybe<String>;
  alias_ends_with?: Maybe<String>;
  alias_not_ends_with?: Maybe<String>;
  artwork_every?: Maybe<ImageWhereInput>;
  artwork_some?: Maybe<ImageWhereInput>;
  artwork_none?: Maybe<ImageWhereInput>;
  collaborative?: Maybe<Boolean>;
  collaborative_not?: Maybe<Boolean>;
  creator?: Maybe<UserWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  numTracks?: Maybe<Int>;
  numTracks_not?: Maybe<Int>;
  numTracks_in?: Maybe<Int[] | Int>;
  numTracks_not_in?: Maybe<Int[] | Int>;
  numTracks_lt?: Maybe<Int>;
  numTracks_lte?: Maybe<Int>;
  numTracks_gt?: Maybe<Int>;
  numTracks_gte?: Maybe<Int>;
  privacy?: Maybe<Privacy>;
  privacy_not?: Maybe<Privacy>;
  privacy_in?: Maybe<Privacy[] | Privacy>;
  privacy_not_in?: Maybe<Privacy[] | Privacy>;
  tracks_every?: Maybe<PlaylistTrackWhereInput>;
  tracks_some?: Maybe<PlaylistTrackWhereInput>;
  tracks_none?: Maybe<PlaylistTrackWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlaylistWhereInput[] | PlaylistWhereInput>;
  OR?: Maybe<PlaylistWhereInput[] | PlaylistWhereInput>;
  NOT?: Maybe<PlaylistWhereInput[] | PlaylistWhereInput>;
}

export interface AudioUpsertNestedInput {
  update: AudioUpdateDataInput;
  create: AudioCreateInput;
}

export interface PlaylistSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlaylistWhereInput>;
  AND?: Maybe<
    PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput
  >;
  OR?: Maybe<PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput>;
  NOT?: Maybe<
    PlaylistSubscriptionWhereInput[] | PlaylistSubscriptionWhereInput
  >;
}

export interface ArtistUpdateManyWithoutFeaturesInInput {
  create?: Maybe<
    ArtistCreateWithoutFeaturesInInput[] | ArtistCreateWithoutFeaturesInInput
  >;
  delete?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  connect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  set?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  disconnect?: Maybe<ArtistWhereUniqueInput[] | ArtistWhereUniqueInput>;
  update?: Maybe<
    | ArtistUpdateWithWhereUniqueWithoutFeaturesInInput[]
    | ArtistUpdateWithWhereUniqueWithoutFeaturesInInput
  >;
  upsert?: Maybe<
    | ArtistUpsertWithWhereUniqueWithoutFeaturesInInput[]
    | ArtistUpsertWithWhereUniqueWithoutFeaturesInInput
  >;
  deleteMany?: Maybe<ArtistScalarWhereInput[] | ArtistScalarWhereInput>;
  updateMany?: Maybe<
    | ArtistUpdateManyWithWhereNestedInput[]
    | ArtistUpdateManyWithWhereNestedInput
  >;
}

export interface AudioSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AudioWhereInput>;
  AND?: Maybe<AudioSubscriptionWhereInput[] | AudioSubscriptionWhereInput>;
  OR?: Maybe<AudioSubscriptionWhereInput[] | AudioSubscriptionWhereInput>;
  NOT?: Maybe<AudioSubscriptionWhereInput[] | AudioSubscriptionWhereInput>;
}

export interface ArtistUpdateWithWhereUniqueWithoutFeaturesInInput {
  where: ArtistWhereUniqueInput;
  data: ArtistUpdateWithoutFeaturesInDataInput;
}

export interface AlbumWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  alias?: Maybe<String>;
  alias_not?: Maybe<String>;
  alias_in?: Maybe<String[] | String>;
  alias_not_in?: Maybe<String[] | String>;
  alias_lt?: Maybe<String>;
  alias_lte?: Maybe<String>;
  alias_gt?: Maybe<String>;
  alias_gte?: Maybe<String>;
  alias_contains?: Maybe<String>;
  alias_not_contains?: Maybe<String>;
  alias_starts_with?: Maybe<String>;
  alias_not_starts_with?: Maybe<String>;
  alias_ends_with?: Maybe<String>;
  alias_not_ends_with?: Maybe<String>;
  artists_every?: Maybe<ArtistWhereInput>;
  artists_some?: Maybe<ArtistWhereInput>;
  artists_none?: Maybe<ArtistWhereInput>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  artwork?: Maybe<ImageWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  numTracks?: Maybe<Int>;
  numTracks_not?: Maybe<Int>;
  numTracks_in?: Maybe<Int[] | Int>;
  numTracks_not_in?: Maybe<Int[] | Int>;
  numTracks_lt?: Maybe<Int>;
  numTracks_lte?: Maybe<Int>;
  numTracks_gt?: Maybe<Int>;
  numTracks_gte?: Maybe<Int>;
  releaseDate?: Maybe<DateTimeInput>;
  releaseDate_not?: Maybe<DateTimeInput>;
  releaseDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  releaseDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  releaseDate_lt?: Maybe<DateTimeInput>;
  releaseDate_lte?: Maybe<DateTimeInput>;
  releaseDate_gt?: Maybe<DateTimeInput>;
  releaseDate_gte?: Maybe<DateTimeInput>;
  releaseType?: Maybe<ReleaseType>;
  releaseType_not?: Maybe<ReleaseType>;
  releaseType_in?: Maybe<ReleaseType[] | ReleaseType>;
  releaseType_not_in?: Maybe<ReleaseType[] | ReleaseType>;
  tracks_every?: Maybe<TrackWhereInput>;
  tracks_some?: Maybe<TrackWhereInput>;
  tracks_none?: Maybe<TrackWhereInput>;
  addedBy?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AlbumWhereInput[] | AlbumWhereInput>;
  OR?: Maybe<AlbumWhereInput[] | AlbumWhereInput>;
  NOT?: Maybe<AlbumWhereInput[] | AlbumWhereInput>;
}

export interface ArtistUpdateWithoutFeaturesInDataInput {
  albums?: Maybe<AlbumUpdateManyWithoutArtistsInput>;
  alias?: Maybe<String>;
  avatar?: Maybe<ImageUpdateOneInput>;
  genres?: Maybe<ArtistUpdategenresInput>;
  name?: Maybe<String>;
  tracks?: Maybe<TrackUpdateManyWithoutArtistsInput>;
}

export interface PlaylistTrackUpdateManyMutationInput {
  addedAt?: Maybe<DateTimeInput>;
}

export interface ArtistUpdategenresInput {
  set?: Maybe<String[] | String>;
}

export interface PlaylistUpdateWithWhereUniqueWithoutTracksInput {
  where: PlaylistWhereUniqueInput;
  data: PlaylistUpdateWithoutTracksDataInput;
}

export interface TrackUpdateManyWithoutArtistsInput {
  create?: Maybe<
    TrackCreateWithoutArtistsInput[] | TrackCreateWithoutArtistsInput
  >;
  delete?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  connect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  set?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  disconnect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  update?: Maybe<
    | TrackUpdateWithWhereUniqueWithoutArtistsInput[]
    | TrackUpdateWithWhereUniqueWithoutArtistsInput
  >;
  upsert?: Maybe<
    | TrackUpsertWithWhereUniqueWithoutArtistsInput[]
    | TrackUpsertWithWhereUniqueWithoutArtistsInput
  >;
  deleteMany?: Maybe<TrackScalarWhereInput[] | TrackScalarWhereInput>;
  updateMany?: Maybe<
    TrackUpdateManyWithWhereNestedInput[] | TrackUpdateManyWithWhereNestedInput
  >;
}

export interface PlaylistTrackUpdateInput {
  addedAt?: Maybe<DateTimeInput>;
  addedBy?: Maybe<UserUpdateOneRequiredInput>;
  playlists?: Maybe<PlaylistUpdateManyWithoutTracksInput>;
  track?: Maybe<TrackUpdateOneRequiredInput>;
}

export interface TrackUpdateWithWhereUniqueWithoutArtistsInput {
  where: TrackWhereUniqueInput;
  data: TrackUpdateWithoutArtistsDataInput;
}

export interface PlaylistTrackCreateInput {
  id?: Maybe<ID_Input>;
  addedAt: DateTimeInput;
  addedBy: UserCreateOneInput;
  playlists?: Maybe<PlaylistCreateManyWithoutTracksInput>;
  track: TrackCreateOneInput;
}

export interface TrackUpdateWithoutArtistsDataInput {
  album?: Maybe<AlbumUpdateOneRequiredWithoutTracksInput>;
  audio?: Maybe<AudioUpdateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  featuring?: Maybe<ArtistUpdateManyWithoutFeaturesInInput>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name?: Maybe<String>;
  trackNumber?: Maybe<Int>;
}

export interface UserUpdateWithoutPlaylistsDataInput {
  isAdmin?: Maybe<Boolean>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  username?: Maybe<String>;
  verified?: Maybe<Boolean>;
}

export interface TrackUpsertWithWhereUniqueWithoutArtistsInput {
  where: TrackWhereUniqueInput;
  update: TrackUpdateWithoutArtistsDataInput;
  create: TrackCreateWithoutArtistsInput;
}

export interface UserCreateWithoutPlaylistsInput {
  id?: Maybe<ID_Input>;
  isAdmin?: Maybe<Boolean>;
  email: String;
  name?: Maybe<String>;
  password: String;
  username?: Maybe<String>;
  verified?: Maybe<Boolean>;
}

export interface TrackScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  discNumber?: Maybe<Int>;
  discNumber_not?: Maybe<Int>;
  discNumber_in?: Maybe<Int[] | Int>;
  discNumber_not_in?: Maybe<Int[] | Int>;
  discNumber_lt?: Maybe<Int>;
  discNumber_lte?: Maybe<Int>;
  discNumber_gt?: Maybe<Int>;
  discNumber_gte?: Maybe<Int>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  explicit_not?: Maybe<Boolean>;
  genre?: Maybe<String>;
  genre_not?: Maybe<String>;
  genre_in?: Maybe<String[] | String>;
  genre_not_in?: Maybe<String[] | String>;
  genre_lt?: Maybe<String>;
  genre_lte?: Maybe<String>;
  genre_gt?: Maybe<String>;
  genre_gte?: Maybe<String>;
  genre_contains?: Maybe<String>;
  genre_not_contains?: Maybe<String>;
  genre_starts_with?: Maybe<String>;
  genre_not_starts_with?: Maybe<String>;
  genre_ends_with?: Maybe<String>;
  genre_not_ends_with?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  isPlayable_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  trackNumber?: Maybe<Int>;
  trackNumber_not?: Maybe<Int>;
  trackNumber_in?: Maybe<Int[] | Int>;
  trackNumber_not_in?: Maybe<Int[] | Int>;
  trackNumber_lt?: Maybe<Int>;
  trackNumber_lte?: Maybe<Int>;
  trackNumber_gt?: Maybe<Int>;
  trackNumber_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TrackScalarWhereInput[] | TrackScalarWhereInput>;
  OR?: Maybe<TrackScalarWhereInput[] | TrackScalarWhereInput>;
  NOT?: Maybe<TrackScalarWhereInput[] | TrackScalarWhereInput>;
}

export interface ImageUpdateManyMutationInput {
  url?: Maybe<String>;
}

export interface TrackUpdateManyWithWhereNestedInput {
  where: TrackScalarWhereInput;
  data: TrackUpdateManyDataInput;
}

export interface AudioUpdateInput {
  bitrate?: Maybe<Int>;
  format?: Maybe<String>;
  size?: Maybe<Int>;
  uploadedBy?: Maybe<UserUpdateOneRequiredInput>;
  url?: Maybe<String>;
}

export interface TrackUpdateManyDataInput {
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name?: Maybe<String>;
  trackNumber?: Maybe<Int>;
}

export interface AlbumCreateInput {
  id?: Maybe<ID_Input>;
  alias: String;
  artists?: Maybe<ArtistCreateManyWithoutAlbumsInput>;
  duration?: Maybe<Int>;
  genres?: Maybe<AlbumCreategenresInput>;
  artwork?: Maybe<ImageCreateOneInput>;
  name: String;
  numTracks?: Maybe<Int>;
  releaseDate: DateTimeInput;
  releaseType: ReleaseType;
  tracks?: Maybe<TrackCreateManyWithoutAlbumInput>;
  addedBy: UserCreateOneInput;
}

export interface ArtistUpsertWithWhereUniqueWithoutFeaturesInInput {
  where: ArtistWhereUniqueInput;
  update: ArtistUpdateWithoutFeaturesInDataInput;
  create: ArtistCreateWithoutFeaturesInInput;
}

export interface ImageCreateInput {
  id?: Maybe<ID_Input>;
  uploadedBy: UserCreateOneInput;
  url: String;
}

export interface ArtistScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  alias?: Maybe<String>;
  alias_not?: Maybe<String>;
  alias_in?: Maybe<String[] | String>;
  alias_not_in?: Maybe<String[] | String>;
  alias_lt?: Maybe<String>;
  alias_lte?: Maybe<String>;
  alias_gt?: Maybe<String>;
  alias_gte?: Maybe<String>;
  alias_contains?: Maybe<String>;
  alias_not_contains?: Maybe<String>;
  alias_starts_with?: Maybe<String>;
  alias_not_starts_with?: Maybe<String>;
  alias_ends_with?: Maybe<String>;
  alias_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ArtistScalarWhereInput[] | ArtistScalarWhereInput>;
  OR?: Maybe<ArtistScalarWhereInput[] | ArtistScalarWhereInput>;
  NOT?: Maybe<ArtistScalarWhereInput[] | ArtistScalarWhereInput>;
}

export interface PlaylistCreateWithoutCreatorInput {
  id?: Maybe<ID_Input>;
  alias: String;
  artwork?: Maybe<ImageCreateManyInput>;
  collaborative?: Maybe<Boolean>;
  description?: Maybe<String>;
  duration: Int;
  name: String;
  numTracks: Int;
  privacy?: Maybe<Privacy>;
  tracks?: Maybe<PlaylistTrackCreateManyWithoutPlaylistsInput>;
}

export interface ArtistUpdateManyWithWhereNestedInput {
  where: ArtistScalarWhereInput;
  data: ArtistUpdateManyDataInput;
}

export interface TrackCreateOneInput {
  create?: Maybe<TrackCreateInput>;
  connect?: Maybe<TrackWhereUniqueInput>;
}

export interface ArtistUpdateManyDataInput {
  alias?: Maybe<String>;
  genres?: Maybe<ArtistUpdategenresInput>;
  name?: Maybe<String>;
}

export interface AlbumCreategenresInput {
  set?: Maybe<String[] | String>;
}

export interface TrackUpsertWithWhereUniqueWithoutAlbumInput {
  where: TrackWhereUniqueInput;
  update: TrackUpdateWithoutAlbumDataInput;
  create: TrackCreateWithoutAlbumInput;
}

export interface AlbumCreateWithoutArtistsInput {
  id?: Maybe<ID_Input>;
  alias: String;
  duration?: Maybe<Int>;
  genres?: Maybe<AlbumCreategenresInput>;
  artwork?: Maybe<ImageCreateOneInput>;
  name: String;
  numTracks?: Maybe<Int>;
  releaseDate: DateTimeInput;
  releaseType: ReleaseType;
  tracks?: Maybe<TrackCreateManyWithoutAlbumInput>;
  addedBy: UserCreateOneInput;
}

export interface AlbumUpsertWithWhereUniqueWithoutArtistsInput {
  where: AlbumWhereUniqueInput;
  update: AlbumUpdateWithoutArtistsDataInput;
  create: AlbumCreateWithoutArtistsInput;
}

export interface AudioCreateInput {
  id?: Maybe<ID_Input>;
  bitrate?: Maybe<Int>;
  format: String;
  size?: Maybe<Int>;
  uploadedBy: UserCreateOneInput;
  url: String;
}

export interface AlbumScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  alias?: Maybe<String>;
  alias_not?: Maybe<String>;
  alias_in?: Maybe<String[] | String>;
  alias_not_in?: Maybe<String[] | String>;
  alias_lt?: Maybe<String>;
  alias_lte?: Maybe<String>;
  alias_gt?: Maybe<String>;
  alias_gte?: Maybe<String>;
  alias_contains?: Maybe<String>;
  alias_not_contains?: Maybe<String>;
  alias_starts_with?: Maybe<String>;
  alias_not_starts_with?: Maybe<String>;
  alias_ends_with?: Maybe<String>;
  alias_not_ends_with?: Maybe<String>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  numTracks?: Maybe<Int>;
  numTracks_not?: Maybe<Int>;
  numTracks_in?: Maybe<Int[] | Int>;
  numTracks_not_in?: Maybe<Int[] | Int>;
  numTracks_lt?: Maybe<Int>;
  numTracks_lte?: Maybe<Int>;
  numTracks_gt?: Maybe<Int>;
  numTracks_gte?: Maybe<Int>;
  releaseDate?: Maybe<DateTimeInput>;
  releaseDate_not?: Maybe<DateTimeInput>;
  releaseDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  releaseDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  releaseDate_lt?: Maybe<DateTimeInput>;
  releaseDate_lte?: Maybe<DateTimeInput>;
  releaseDate_gt?: Maybe<DateTimeInput>;
  releaseDate_gte?: Maybe<DateTimeInput>;
  releaseType?: Maybe<ReleaseType>;
  releaseType_not?: Maybe<ReleaseType>;
  releaseType_in?: Maybe<ReleaseType[] | ReleaseType>;
  releaseType_not_in?: Maybe<ReleaseType[] | ReleaseType>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AlbumScalarWhereInput[] | AlbumScalarWhereInput>;
  OR?: Maybe<AlbumScalarWhereInput[] | AlbumScalarWhereInput>;
  NOT?: Maybe<AlbumScalarWhereInput[] | AlbumScalarWhereInput>;
}

export interface AudioWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  bitrate?: Maybe<Int>;
  bitrate_not?: Maybe<Int>;
  bitrate_in?: Maybe<Int[] | Int>;
  bitrate_not_in?: Maybe<Int[] | Int>;
  bitrate_lt?: Maybe<Int>;
  bitrate_lte?: Maybe<Int>;
  bitrate_gt?: Maybe<Int>;
  bitrate_gte?: Maybe<Int>;
  format?: Maybe<String>;
  format_not?: Maybe<String>;
  format_in?: Maybe<String[] | String>;
  format_not_in?: Maybe<String[] | String>;
  format_lt?: Maybe<String>;
  format_lte?: Maybe<String>;
  format_gt?: Maybe<String>;
  format_gte?: Maybe<String>;
  format_contains?: Maybe<String>;
  format_not_contains?: Maybe<String>;
  format_starts_with?: Maybe<String>;
  format_not_starts_with?: Maybe<String>;
  format_ends_with?: Maybe<String>;
  format_not_ends_with?: Maybe<String>;
  size?: Maybe<Int>;
  size_not?: Maybe<Int>;
  size_in?: Maybe<Int[] | Int>;
  size_not_in?: Maybe<Int[] | Int>;
  size_lt?: Maybe<Int>;
  size_lte?: Maybe<Int>;
  size_gt?: Maybe<Int>;
  size_gte?: Maybe<Int>;
  uploadedBy?: Maybe<UserWhereInput>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AudioWhereInput[] | AudioWhereInput>;
  OR?: Maybe<AudioWhereInput[] | AudioWhereInput>;
  NOT?: Maybe<AudioWhereInput[] | AudioWhereInput>;
}

export interface AlbumUpdateManyWithWhereNestedInput {
  where: AlbumScalarWhereInput;
  data: AlbumUpdateManyDataInput;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  OR?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  NOT?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface AlbumUpdateManyDataInput {
  alias?: Maybe<String>;
  duration?: Maybe<Int>;
  genres?: Maybe<AlbumUpdategenresInput>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  releaseDate?: Maybe<DateTimeInput>;
  releaseType?: Maybe<ReleaseType>;
}

export interface TrackUpdateManyMutationInput {
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name?: Maybe<String>;
  trackNumber?: Maybe<Int>;
}

export interface TrackUpdateManyWithoutFeaturingInput {
  create?: Maybe<
    TrackCreateWithoutFeaturingInput[] | TrackCreateWithoutFeaturingInput
  >;
  delete?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  connect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  set?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  disconnect?: Maybe<TrackWhereUniqueInput[] | TrackWhereUniqueInput>;
  update?: Maybe<
    | TrackUpdateWithWhereUniqueWithoutFeaturingInput[]
    | TrackUpdateWithWhereUniqueWithoutFeaturingInput
  >;
  upsert?: Maybe<
    | TrackUpsertWithWhereUniqueWithoutFeaturingInput[]
    | TrackUpsertWithWhereUniqueWithoutFeaturingInput
  >;
  deleteMany?: Maybe<TrackScalarWhereInput[] | TrackScalarWhereInput>;
  updateMany?: Maybe<
    TrackUpdateManyWithWhereNestedInput[] | TrackUpdateManyWithWhereNestedInput
  >;
}

export interface ArtistWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  albums_every?: Maybe<AlbumWhereInput>;
  albums_some?: Maybe<AlbumWhereInput>;
  albums_none?: Maybe<AlbumWhereInput>;
  alias?: Maybe<String>;
  alias_not?: Maybe<String>;
  alias_in?: Maybe<String[] | String>;
  alias_not_in?: Maybe<String[] | String>;
  alias_lt?: Maybe<String>;
  alias_lte?: Maybe<String>;
  alias_gt?: Maybe<String>;
  alias_gte?: Maybe<String>;
  alias_contains?: Maybe<String>;
  alias_not_contains?: Maybe<String>;
  alias_starts_with?: Maybe<String>;
  alias_not_starts_with?: Maybe<String>;
  alias_ends_with?: Maybe<String>;
  alias_not_ends_with?: Maybe<String>;
  avatar?: Maybe<ImageWhereInput>;
  featuresIn_every?: Maybe<TrackWhereInput>;
  featuresIn_some?: Maybe<TrackWhereInput>;
  featuresIn_none?: Maybe<TrackWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  tracks_every?: Maybe<TrackWhereInput>;
  tracks_some?: Maybe<TrackWhereInput>;
  tracks_none?: Maybe<TrackWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ArtistWhereInput[] | ArtistWhereInput>;
  OR?: Maybe<ArtistWhereInput[] | ArtistWhereInput>;
  NOT?: Maybe<ArtistWhereInput[] | ArtistWhereInput>;
}

export interface TrackUpdateWithWhereUniqueWithoutFeaturingInput {
  where: TrackWhereUniqueInput;
  data: TrackUpdateWithoutFeaturingDataInput;
}

export type PlaylistWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  alias?: Maybe<String>;
}>;

export interface TrackUpdateWithoutFeaturingDataInput {
  album?: Maybe<AlbumUpdateOneRequiredWithoutTracksInput>;
  artists?: Maybe<ArtistUpdateManyWithoutTracksInput>;
  audio?: Maybe<AudioUpdateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name?: Maybe<String>;
  trackNumber?: Maybe<Int>;
}

export type TrackWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TrackUpsertWithWhereUniqueWithoutFeaturingInput {
  where: TrackWhereUniqueInput;
  update: TrackUpdateWithoutFeaturingDataInput;
  create: TrackCreateWithoutFeaturingInput;
}

export interface ArtistUpdateInput {
  albums?: Maybe<AlbumUpdateManyWithoutArtistsInput>;
  alias?: Maybe<String>;
  avatar?: Maybe<ImageUpdateOneInput>;
  featuresIn?: Maybe<TrackUpdateManyWithoutFeaturingInput>;
  genres?: Maybe<ArtistUpdategenresInput>;
  name?: Maybe<String>;
  tracks?: Maybe<TrackUpdateManyWithoutArtistsInput>;
}

export interface ArtistUpsertWithWhereUniqueWithoutTracksInput {
  where: ArtistWhereUniqueInput;
  update: ArtistUpdateWithoutTracksDataInput;
  create: ArtistCreateWithoutTracksInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  isAdmin?: Maybe<Boolean>;
  email: String;
  name?: Maybe<String>;
  password: String;
  playlists?: Maybe<PlaylistCreateManyWithoutCreatorInput>;
  username?: Maybe<String>;
  verified?: Maybe<Boolean>;
}

export interface TrackUpsertNestedInput {
  update: TrackUpdateDataInput;
  create: TrackCreateInput;
}

export interface AlbumCreateOneWithoutTracksInput {
  create?: Maybe<AlbumCreateWithoutTracksInput>;
  connect?: Maybe<AlbumWhereUniqueInput>;
}

export interface PlaylistTrackUpsertWithWhereUniqueWithoutPlaylistsInput {
  where: PlaylistTrackWhereUniqueInput;
  update: PlaylistTrackUpdateWithoutPlaylistsDataInput;
  create: PlaylistTrackCreateWithoutPlaylistsInput;
}

export interface TrackCreateWithoutAlbumInput {
  id?: Maybe<ID_Input>;
  artists?: Maybe<ArtistCreateManyWithoutTracksInput>;
  audio?: Maybe<AudioCreateOneInput>;
  discNumber?: Maybe<Int>;
  duration?: Maybe<Int>;
  explicit?: Maybe<Boolean>;
  featuring?: Maybe<ArtistCreateManyWithoutFeaturesInInput>;
  genre?: Maybe<String>;
  isPlayable?: Maybe<Boolean>;
  name: String;
  trackNumber: Int;
}

export interface PlaylistTrackScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  addedAt?: Maybe<DateTimeInput>;
  addedAt_not?: Maybe<DateTimeInput>;
  addedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  addedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  addedAt_lt?: Maybe<DateTimeInput>;
  addedAt_lte?: Maybe<DateTimeInput>;
  addedAt_gt?: Maybe<DateTimeInput>;
  addedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlaylistTrackScalarWhereInput[] | PlaylistTrackScalarWhereInput>;
  OR?: Maybe<PlaylistTrackScalarWhereInput[] | PlaylistTrackScalarWhereInput>;
  NOT?: Maybe<PlaylistTrackScalarWhereInput[] | PlaylistTrackScalarWhereInput>;
}

export interface TrackSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrackWhereInput>;
  AND?: Maybe<TrackSubscriptionWhereInput[] | TrackSubscriptionWhereInput>;
  OR?: Maybe<TrackSubscriptionWhereInput[] | TrackSubscriptionWhereInput>;
  NOT?: Maybe<TrackSubscriptionWhereInput[] | TrackSubscriptionWhereInput>;
}

export interface PlaylistTrackUpdateManyWithWhereNestedInput {
  where: PlaylistTrackScalarWhereInput;
  data: PlaylistTrackUpdateManyDataInput;
}

export interface PlaylistUpsertWithWhereUniqueWithoutTracksInput {
  where: PlaylistWhereUniqueInput;
  update: PlaylistUpdateWithoutTracksDataInput;
  create: PlaylistCreateWithoutTracksInput;
}

export interface PlaylistTrackUpdateManyDataInput {
  addedAt?: Maybe<DateTimeInput>;
}

export type PlaylistTrackWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PlaylistUpsertWithWhereUniqueWithoutCreatorInput {
  where: PlaylistWhereUniqueInput;
  update: PlaylistUpdateWithoutCreatorDataInput;
  create: PlaylistCreateWithoutCreatorInput;
}

export interface ArtistCreateWithoutAlbumsInput {
  id?: Maybe<ID_Input>;
  alias: String;
  avatar?: Maybe<ImageCreateOneInput>;
  featuresIn?: Maybe<TrackCreateManyWithoutFeaturingInput>;
  genres?: Maybe<ArtistCreategenresInput>;
  name: String;
  tracks?: Maybe<TrackCreateManyWithoutArtistsInput>;
}

export interface PlaylistScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  alias?: Maybe<String>;
  alias_not?: Maybe<String>;
  alias_in?: Maybe<String[] | String>;
  alias_not_in?: Maybe<String[] | String>;
  alias_lt?: Maybe<String>;
  alias_lte?: Maybe<String>;
  alias_gt?: Maybe<String>;
  alias_gte?: Maybe<String>;
  alias_contains?: Maybe<String>;
  alias_not_contains?: Maybe<String>;
  alias_starts_with?: Maybe<String>;
  alias_not_starts_with?: Maybe<String>;
  alias_ends_with?: Maybe<String>;
  alias_not_ends_with?: Maybe<String>;
  collaborative?: Maybe<Boolean>;
  collaborative_not?: Maybe<Boolean>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  duration?: Maybe<Int>;
  duration_not?: Maybe<Int>;
  duration_in?: Maybe<Int[] | Int>;
  duration_not_in?: Maybe<Int[] | Int>;
  duration_lt?: Maybe<Int>;
  duration_lte?: Maybe<Int>;
  duration_gt?: Maybe<Int>;
  duration_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  numTracks?: Maybe<Int>;
  numTracks_not?: Maybe<Int>;
  numTracks_in?: Maybe<Int[] | Int>;
  numTracks_not_in?: Maybe<Int[] | Int>;
  numTracks_lt?: Maybe<Int>;
  numTracks_lte?: Maybe<Int>;
  numTracks_gt?: Maybe<Int>;
  numTracks_gte?: Maybe<Int>;
  privacy?: Maybe<Privacy>;
  privacy_not?: Maybe<Privacy>;
  privacy_in?: Maybe<Privacy[] | Privacy>;
  privacy_not_in?: Maybe<Privacy[] | Privacy>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PlaylistScalarWhereInput[] | PlaylistScalarWhereInput>;
  OR?: Maybe<PlaylistScalarWhereInput[] | PlaylistScalarWhereInput>;
  NOT?: Maybe<PlaylistScalarWhereInput[] | PlaylistScalarWhereInput>;
}

export interface ArtistCreateWithoutTracksInput {
  id?: Maybe<ID_Input>;
  albums?: Maybe<AlbumCreateManyWithoutArtistsInput>;
  alias: String;
  avatar?: Maybe<ImageCreateOneInput>;
  featuresIn?: Maybe<TrackCreateManyWithoutFeaturingInput>;
  genres?: Maybe<ArtistCreategenresInput>;
  name: String;
}

export interface PlaylistUpdateManyWithWhereNestedInput {
  where: PlaylistScalarWhereInput;
  data: PlaylistUpdateManyDataInput;
}

export interface AlbumSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AlbumWhereInput>;
  AND?: Maybe<AlbumSubscriptionWhereInput[] | AlbumSubscriptionWhereInput>;
  OR?: Maybe<AlbumSubscriptionWhereInput[] | AlbumSubscriptionWhereInput>;
  NOT?: Maybe<AlbumSubscriptionWhereInput[] | AlbumSubscriptionWhereInput>;
}

export interface ArtistUpsertWithWhereUniqueWithoutAlbumsInput {
  where: ArtistWhereUniqueInput;
  update: ArtistUpdateWithoutAlbumsDataInput;
  create: ArtistCreateWithoutAlbumsInput;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PlaylistUpdateManyDataInput {
  alias?: Maybe<String>;
  collaborative?: Maybe<Boolean>;
  description?: Maybe<String>;
  duration?: Maybe<Int>;
  name?: Maybe<String>;
  numTracks?: Maybe<Int>;
  privacy?: Maybe<Privacy>;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ArtistCreateWithoutFeaturesInInput {
  id?: Maybe<ID_Input>;
  albums?: Maybe<AlbumCreateManyWithoutArtistsInput>;
  alias: String;
  avatar?: Maybe<ImageCreateOneInput>;
  genres?: Maybe<ArtistCreategenresInput>;
  name: String;
  tracks?: Maybe<TrackCreateManyWithoutArtistsInput>;
}

export interface PlaylistTrackCreateManyWithoutPlaylistsInput {
  create?: Maybe<
    | PlaylistTrackCreateWithoutPlaylistsInput[]
    | PlaylistTrackCreateWithoutPlaylistsInput
  >;
  connect?: Maybe<
    PlaylistTrackWhereUniqueInput[] | PlaylistTrackWhereUniqueInput
  >;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  username?: Maybe<String>;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  isAdmin: Boolean;
  name: String;
  username: String;
  verified: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isAdmin: () => Promise<Boolean>;
  name: () => Promise<String>;
  username: () => Promise<String>;
  verified: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AlbumEdge {
  node: Album;
  cursor: String;
}

export interface AlbumEdgePromise extends Promise<AlbumEdge>, Fragmentable {
  node: <T = AlbumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AlbumEdgeSubscription
  extends Promise<AsyncIterator<AlbumEdge>>,
    Fragmentable {
  node: <T = AlbumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrackSubscriptionPayload {
  mutation: MutationType;
  node: Track;
  updatedFields: String[];
  previousValues: TrackPreviousValues;
}

export interface TrackSubscriptionPayloadPromise
  extends Promise<TrackSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrackPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrackPreviousValuesPromise>() => T;
}

export interface TrackSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrackSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrackSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrackPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AlbumConnection {
  pageInfo: PageInfo;
  edges: AlbumEdge[];
}

export interface AlbumConnectionPromise
  extends Promise<AlbumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AlbumEdge>>() => T;
  aggregate: <T = AggregateAlbumPromise>() => T;
}

export interface AlbumConnectionSubscription
  extends Promise<AsyncIterator<AlbumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AlbumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAlbumSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Audio {
  id: ID_Output;
  bitrate?: Int;
  format: String;
  size?: Int;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AudioPromise extends Promise<Audio>, Fragmentable {
  id: () => Promise<ID_Output>;
  bitrate: () => Promise<Int>;
  format: () => Promise<String>;
  size: () => Promise<Int>;
  uploadedBy: <T = UserPromise>() => T;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AudioSubscription
  extends Promise<AsyncIterator<Audio>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bitrate: () => Promise<AsyncIterator<Int>>;
  format: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  uploadedBy: <T = UserSubscription>() => T;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AudioNullablePromise
  extends Promise<Audio | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bitrate: () => Promise<Int>;
  format: () => Promise<String>;
  size: () => Promise<Int>;
  uploadedBy: <T = UserPromise>() => T;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateTrack {
  count: Int;
}

export interface AggregateTrackPromise
  extends Promise<AggregateTrack>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrackSubscription
  extends Promise<AsyncIterator<AggregateTrack>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Track {
  id: ID_Output;
  discNumber?: Int;
  duration?: Int;
  explicit: Boolean;
  genre: String;
  isPlayable: Boolean;
  name: String;
  trackNumber: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TrackPromise extends Promise<Track>, Fragmentable {
  id: () => Promise<ID_Output>;
  album: <T = AlbumPromise>() => T;
  artists: <T = FragmentableArray<Artist>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  audio: <T = AudioPromise>() => T;
  discNumber: () => Promise<Int>;
  duration: () => Promise<Int>;
  explicit: () => Promise<Boolean>;
  featuring: <T = FragmentableArray<Artist>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  genre: () => Promise<String>;
  isPlayable: () => Promise<Boolean>;
  name: () => Promise<String>;
  trackNumber: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TrackSubscription
  extends Promise<AsyncIterator<Track>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  album: <T = AlbumSubscription>() => T;
  artists: <T = Promise<AsyncIterator<ArtistSubscription>>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  audio: <T = AudioSubscription>() => T;
  discNumber: () => Promise<AsyncIterator<Int>>;
  duration: () => Promise<AsyncIterator<Int>>;
  explicit: () => Promise<AsyncIterator<Boolean>>;
  featuring: <T = Promise<AsyncIterator<ArtistSubscription>>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  genre: () => Promise<AsyncIterator<String>>;
  isPlayable: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  trackNumber: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TrackNullablePromise
  extends Promise<Track | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  album: <T = AlbumPromise>() => T;
  artists: <T = FragmentableArray<Artist>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  audio: <T = AudioPromise>() => T;
  discNumber: () => Promise<Int>;
  duration: () => Promise<Int>;
  explicit: () => Promise<Boolean>;
  featuring: <T = FragmentableArray<Artist>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  genre: () => Promise<String>;
  isPlayable: () => Promise<Boolean>;
  name: () => Promise<String>;
  trackNumber: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TrackConnection {
  pageInfo: PageInfo;
  edges: TrackEdge[];
}

export interface TrackConnectionPromise
  extends Promise<TrackConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrackEdge>>() => T;
  aggregate: <T = AggregateTrackPromise>() => T;
}

export interface TrackConnectionSubscription
  extends Promise<AsyncIterator<TrackConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrackEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrackSubscription>() => T;
}

export interface Artist {
  id: ID_Output;
  alias: String;
  genres: String[];
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ArtistPromise extends Promise<Artist>, Fragmentable {
  id: () => Promise<ID_Output>;
  albums: <T = FragmentableArray<Album>>(args?: {
    where?: AlbumWhereInput;
    orderBy?: AlbumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  alias: () => Promise<String>;
  avatar: <T = ImagePromise>() => T;
  featuresIn: <T = FragmentableArray<Track>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  genres: () => Promise<String[]>;
  name: () => Promise<String>;
  tracks: <T = FragmentableArray<Track>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ArtistSubscription
  extends Promise<AsyncIterator<Artist>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  albums: <T = Promise<AsyncIterator<AlbumSubscription>>>(args?: {
    where?: AlbumWhereInput;
    orderBy?: AlbumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  alias: () => Promise<AsyncIterator<String>>;
  avatar: <T = ImageSubscription>() => T;
  featuresIn: <T = Promise<AsyncIterator<TrackSubscription>>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  genres: () => Promise<AsyncIterator<String[]>>;
  name: () => Promise<AsyncIterator<String>>;
  tracks: <T = Promise<AsyncIterator<TrackSubscription>>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ArtistNullablePromise
  extends Promise<Artist | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  albums: <T = FragmentableArray<Album>>(args?: {
    where?: AlbumWhereInput;
    orderBy?: AlbumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  alias: () => Promise<String>;
  avatar: <T = ImagePromise>() => T;
  featuresIn: <T = FragmentableArray<Track>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  genres: () => Promise<String[]>;
  name: () => Promise<String>;
  tracks: <T = FragmentableArray<Track>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistTrackEdge {
  node: PlaylistTrack;
  cursor: String;
}

export interface PlaylistTrackEdgePromise
  extends Promise<PlaylistTrackEdge>,
    Fragmentable {
  node: <T = PlaylistTrackPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaylistTrackEdgeSubscription
  extends Promise<AsyncIterator<PlaylistTrackEdge>>,
    Fragmentable {
  node: <T = PlaylistTrackSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AlbumSubscriptionPayload {
  mutation: MutationType;
  node: Album;
  updatedFields: String[];
  previousValues: AlbumPreviousValues;
}

export interface AlbumSubscriptionPayloadPromise
  extends Promise<AlbumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AlbumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AlbumPreviousValuesPromise>() => T;
}

export interface AlbumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AlbumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AlbumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AlbumPreviousValuesSubscription>() => T;
}

export interface AggregatePlaylist {
  count: Int;
}

export interface AggregatePlaylistPromise
  extends Promise<AggregatePlaylist>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaylistSubscription
  extends Promise<AsyncIterator<AggregatePlaylist>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AlbumPreviousValues {
  id: ID_Output;
  alias: String;
  duration?: Int;
  genres: String[];
  name: String;
  numTracks?: Int;
  releaseDate: DateTimeOutput;
  releaseType: ReleaseType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AlbumPreviousValuesPromise
  extends Promise<AlbumPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  alias: () => Promise<String>;
  duration: () => Promise<Int>;
  genres: () => Promise<String[]>;
  name: () => Promise<String>;
  numTracks: () => Promise<Int>;
  releaseDate: () => Promise<DateTimeOutput>;
  releaseType: () => Promise<ReleaseType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AlbumPreviousValuesSubscription
  extends Promise<AsyncIterator<AlbumPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  alias: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  genres: () => Promise<AsyncIterator<String[]>>;
  name: () => Promise<AsyncIterator<String>>;
  numTracks: () => Promise<AsyncIterator<Int>>;
  releaseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  releaseType: () => Promise<AsyncIterator<ReleaseType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaylistConnection {
  pageInfo: PageInfo;
  edges: PlaylistEdge[];
}

export interface PlaylistConnectionPromise
  extends Promise<PlaylistConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaylistEdge>>() => T;
  aggregate: <T = AggregatePlaylistPromise>() => T;
}

export interface PlaylistConnectionSubscription
  extends Promise<AsyncIterator<PlaylistConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaylistEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaylistSubscription>() => T;
}

export interface PlaylistTrack {
  id: ID_Output;
  addedAt: DateTimeOutput;
}

export interface PlaylistTrackPromise
  extends Promise<PlaylistTrack>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  addedAt: () => Promise<DateTimeOutput>;
  addedBy: <T = UserPromise>() => T;
  playlists: <T = FragmentableArray<Playlist>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  track: <T = TrackPromise>() => T;
}

export interface PlaylistTrackSubscription
  extends Promise<AsyncIterator<PlaylistTrack>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  addedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  addedBy: <T = UserSubscription>() => T;
  playlists: <T = Promise<AsyncIterator<PlaylistSubscription>>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  track: <T = TrackSubscription>() => T;
}

export interface PlaylistTrackNullablePromise
  extends Promise<PlaylistTrack | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  addedAt: () => Promise<DateTimeOutput>;
  addedBy: <T = UserPromise>() => T;
  playlists: <T = FragmentableArray<Playlist>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  track: <T = TrackPromise>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ArtistSubscriptionPayload {
  mutation: MutationType;
  node: Artist;
  updatedFields: String[];
  previousValues: ArtistPreviousValues;
}

export interface ArtistSubscriptionPayloadPromise
  extends Promise<ArtistSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArtistPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArtistPreviousValuesPromise>() => T;
}

export interface ArtistSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArtistSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArtistSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArtistPreviousValuesSubscription>() => T;
}

export interface AggregateAudio {
  count: Int;
}

export interface AggregateAudioPromise
  extends Promise<AggregateAudio>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAudioSubscription
  extends Promise<AsyncIterator<AggregateAudio>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArtistPreviousValues {
  id: ID_Output;
  alias: String;
  genres: String[];
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ArtistPreviousValuesPromise
  extends Promise<ArtistPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  alias: () => Promise<String>;
  genres: () => Promise<String[]>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ArtistPreviousValuesSubscription
  extends Promise<AsyncIterator<ArtistPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  alias: () => Promise<AsyncIterator<String>>;
  genres: () => Promise<AsyncIterator<String[]>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AudioConnection {
  pageInfo: PageInfo;
  edges: AudioEdge[];
}

export interface AudioConnectionPromise
  extends Promise<AudioConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AudioEdge>>() => T;
  aggregate: <T = AggregateAudioPromise>() => T;
}

export interface AudioConnectionSubscription
  extends Promise<AsyncIterator<AudioConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AudioEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAudioSubscription>() => T;
}

export interface TrackPreviousValues {
  id: ID_Output;
  discNumber?: Int;
  duration?: Int;
  explicit: Boolean;
  genre: String;
  isPlayable: Boolean;
  name: String;
  trackNumber: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TrackPreviousValuesPromise
  extends Promise<TrackPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  discNumber: () => Promise<Int>;
  duration: () => Promise<Int>;
  explicit: () => Promise<Boolean>;
  genre: () => Promise<String>;
  isPlayable: () => Promise<Boolean>;
  name: () => Promise<String>;
  trackNumber: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TrackPreviousValuesSubscription
  extends Promise<AsyncIterator<TrackPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  discNumber: () => Promise<AsyncIterator<Int>>;
  duration: () => Promise<AsyncIterator<Int>>;
  explicit: () => Promise<AsyncIterator<Boolean>>;
  genre: () => Promise<AsyncIterator<String>>;
  isPlayable: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  trackNumber: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ArtistEdge {
  node: Artist;
  cursor: String;
}

export interface ArtistEdgePromise extends Promise<ArtistEdge>, Fragmentable {
  node: <T = ArtistPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArtistEdgeSubscription
  extends Promise<AsyncIterator<ArtistEdge>>,
    Fragmentable {
  node: <T = ArtistSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AudioSubscriptionPayload {
  mutation: MutationType;
  node: Audio;
  updatedFields: String[];
  previousValues: AudioPreviousValues;
}

export interface AudioSubscriptionPayloadPromise
  extends Promise<AudioSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AudioPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AudioPreviousValuesPromise>() => T;
}

export interface AudioSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AudioSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AudioSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AudioPreviousValuesSubscription>() => T;
}

export interface AggregateAlbum {
  count: Int;
}

export interface AggregateAlbumPromise
  extends Promise<AggregateAlbum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAlbumSubscription
  extends Promise<AsyncIterator<AggregateAlbum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AudioPreviousValues {
  id: ID_Output;
  bitrate?: Int;
  format: String;
  size?: Int;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AudioPreviousValuesPromise
  extends Promise<AudioPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bitrate: () => Promise<Int>;
  format: () => Promise<String>;
  size: () => Promise<Int>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AudioPreviousValuesSubscription
  extends Promise<AsyncIterator<AudioPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bitrate: () => Promise<AsyncIterator<Int>>;
  format: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Int>>;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Album {
  id: ID_Output;
  alias: String;
  duration?: Int;
  genres: String[];
  name: String;
  numTracks?: Int;
  releaseDate: DateTimeOutput;
  releaseType: ReleaseType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AlbumPromise extends Promise<Album>, Fragmentable {
  id: () => Promise<ID_Output>;
  alias: () => Promise<String>;
  artists: <T = FragmentableArray<Artist>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Int>;
  genres: () => Promise<String[]>;
  artwork: <T = ImagePromise>() => T;
  name: () => Promise<String>;
  numTracks: () => Promise<Int>;
  releaseDate: () => Promise<DateTimeOutput>;
  releaseType: () => Promise<ReleaseType>;
  tracks: <T = FragmentableArray<Track>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AlbumSubscription
  extends Promise<AsyncIterator<Album>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  alias: () => Promise<AsyncIterator<String>>;
  artists: <T = Promise<AsyncIterator<ArtistSubscription>>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<AsyncIterator<Int>>;
  genres: () => Promise<AsyncIterator<String[]>>;
  artwork: <T = ImageSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  numTracks: () => Promise<AsyncIterator<Int>>;
  releaseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  releaseType: () => Promise<AsyncIterator<ReleaseType>>;
  tracks: <T = Promise<AsyncIterator<TrackSubscription>>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addedBy: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AlbumNullablePromise
  extends Promise<Album | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  alias: () => Promise<String>;
  artists: <T = FragmentableArray<Artist>>(args?: {
    where?: ArtistWhereInput;
    orderBy?: ArtistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  duration: () => Promise<Int>;
  genres: () => Promise<String[]>;
  artwork: <T = ImagePromise>() => T;
  name: () => Promise<String>;
  numTracks: () => Promise<Int>;
  releaseDate: () => Promise<DateTimeOutput>;
  releaseType: () => Promise<ReleaseType>;
  tracks: <T = FragmentableArray<Track>>(args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addedBy: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Playlist {
  id: ID_Output;
  alias: String;
  collaborative: Boolean;
  description?: String;
  duration: Int;
  name: String;
  numTracks: Int;
  privacy: Privacy;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlaylistPromise extends Promise<Playlist>, Fragmentable {
  id: () => Promise<ID_Output>;
  alias: () => Promise<String>;
  artwork: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  collaborative: () => Promise<Boolean>;
  creator: <T = UserPromise>() => T;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  name: () => Promise<String>;
  numTracks: () => Promise<Int>;
  privacy: () => Promise<Privacy>;
  tracks: <T = FragmentableArray<PlaylistTrack>>(args?: {
    where?: PlaylistTrackWhereInput;
    orderBy?: PlaylistTrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistSubscription
  extends Promise<AsyncIterator<Playlist>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  alias: () => Promise<AsyncIterator<String>>;
  artwork: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  collaborative: () => Promise<AsyncIterator<Boolean>>;
  creator: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  numTracks: () => Promise<AsyncIterator<Int>>;
  privacy: () => Promise<AsyncIterator<Privacy>>;
  tracks: <T = Promise<AsyncIterator<PlaylistTrackSubscription>>>(args?: {
    where?: PlaylistTrackWhereInput;
    orderBy?: PlaylistTrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaylistNullablePromise
  extends Promise<Playlist | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  alias: () => Promise<String>;
  artwork: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  collaborative: () => Promise<Boolean>;
  creator: <T = UserPromise>() => T;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  name: () => Promise<String>;
  numTracks: () => Promise<Int>;
  privacy: () => Promise<Privacy>;
  tracks: <T = FragmentableArray<PlaylistTrack>>(args?: {
    where?: PlaylistTrackWhereInput;
    orderBy?: PlaylistTrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregatePlaylistTrack {
  count: Int;
}

export interface AggregatePlaylistTrackPromise
  extends Promise<AggregatePlaylistTrack>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlaylistTrackSubscription
  extends Promise<AsyncIterator<AggregatePlaylistTrack>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface PlaylistEdge {
  node: Playlist;
  cursor: String;
}

export interface PlaylistEdgePromise
  extends Promise<PlaylistEdge>,
    Fragmentable {
  node: <T = PlaylistPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlaylistEdgeSubscription
  extends Promise<AsyncIterator<PlaylistEdge>>,
    Fragmentable {
  node: <T = PlaylistSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImagePreviousValues {
  id: ID_Output;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface User {
  id: ID_Output;
  isAdmin: Boolean;
  email: String;
  name?: String;
  password: String;
  username?: String;
  verified: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  isAdmin: () => Promise<Boolean>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  playlists: <T = FragmentableArray<Playlist>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  username: () => Promise<String>;
  verified: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  playlists: <T = Promise<AsyncIterator<PlaylistSubscription>>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  username: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isAdmin: () => Promise<Boolean>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  playlists: <T = FragmentableArray<Playlist>>(args?: {
    where?: PlaylistWhereInput;
    orderBy?: PlaylistOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  username: () => Promise<String>;
  verified: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateArtist {
  count: Int;
}

export interface AggregateArtistPromise
  extends Promise<AggregateArtist>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArtistSubscription
  extends Promise<AsyncIterator<AggregateArtist>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlaylistSubscriptionPayload {
  mutation: MutationType;
  node: Playlist;
  updatedFields: String[];
  previousValues: PlaylistPreviousValues;
}

export interface PlaylistSubscriptionPayloadPromise
  extends Promise<PlaylistSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaylistPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaylistPreviousValuesPromise>() => T;
}

export interface PlaylistSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaylistSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaylistSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaylistPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PlaylistTrackConnection {
  pageInfo: PageInfo;
  edges: PlaylistTrackEdge[];
}

export interface PlaylistTrackConnectionPromise
  extends Promise<PlaylistTrackConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlaylistTrackEdge>>() => T;
  aggregate: <T = AggregatePlaylistTrackPromise>() => T;
}

export interface PlaylistTrackConnectionSubscription
  extends Promise<AsyncIterator<PlaylistTrackConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlaylistTrackEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlaylistTrackSubscription>() => T;
}

export interface PlaylistTrackPreviousValues {
  id: ID_Output;
  addedAt: DateTimeOutput;
}

export interface PlaylistTrackPreviousValuesPromise
  extends Promise<PlaylistTrackPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  addedAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistTrackPreviousValuesSubscription
  extends Promise<AsyncIterator<PlaylistTrackPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  addedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PlaylistTrackSubscriptionPayload {
  mutation: MutationType;
  node: PlaylistTrack;
  updatedFields: String[];
  previousValues: PlaylistTrackPreviousValues;
}

export interface PlaylistTrackSubscriptionPayloadPromise
  extends Promise<PlaylistTrackSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlaylistTrackPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlaylistTrackPreviousValuesPromise>() => T;
}

export interface PlaylistTrackSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlaylistTrackSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlaylistTrackSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlaylistTrackPreviousValuesSubscription>() => T;
}

export interface Image {
  id: ID_Output;
  url: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  uploadedBy: <T = UserPromise>() => T;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  uploadedBy: <T = UserSubscription>() => T;
  url: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageNullablePromise
  extends Promise<Image | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  uploadedBy: <T = UserPromise>() => T;
  url: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistPreviousValues {
  id: ID_Output;
  alias: String;
  collaborative: Boolean;
  description?: String;
  duration: Int;
  name: String;
  numTracks: Int;
  privacy: Privacy;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PlaylistPreviousValuesPromise
  extends Promise<PlaylistPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  alias: () => Promise<String>;
  collaborative: () => Promise<Boolean>;
  description: () => Promise<String>;
  duration: () => Promise<Int>;
  name: () => Promise<String>;
  numTracks: () => Promise<Int>;
  privacy: () => Promise<Privacy>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PlaylistPreviousValuesSubscription
  extends Promise<AsyncIterator<PlaylistPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  alias: () => Promise<AsyncIterator<String>>;
  collaborative: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  numTracks: () => Promise<AsyncIterator<Int>>;
  privacy: () => Promise<AsyncIterator<Privacy>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TrackEdge {
  node: Track;
  cursor: String;
}

export interface TrackEdgePromise extends Promise<TrackEdge>, Fragmentable {
  node: <T = TrackPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrackEdgeSubscription
  extends Promise<AsyncIterator<TrackEdge>>,
    Fragmentable {
  node: <T = TrackSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ArtistConnection {
  pageInfo: PageInfo;
  edges: ArtistEdge[];
}

export interface ArtistConnectionPromise
  extends Promise<ArtistConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArtistEdge>>() => T;
  aggregate: <T = AggregateArtistPromise>() => T;
}

export interface ArtistConnectionSubscription
  extends Promise<AsyncIterator<ArtistConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArtistEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArtistSubscription>() => T;
}

export interface AudioEdge {
  node: Audio;
  cursor: String;
}

export interface AudioEdgePromise extends Promise<AudioEdge>, Fragmentable {
  node: <T = AudioPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AudioEdgeSubscription
  extends Promise<AsyncIterator<AudioEdge>>,
    Fragmentable {
  node: <T = AudioSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Artist",
    embedded: false
  },
  {
    name: "Track",
    embedded: false
  },
  {
    name: "Album",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Audio",
    embedded: false
  },
  {
    name: "Playlist",
    embedded: false
  },
  {
    name: "PlaylistTrack",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "ReleaseType",
    embedded: false
  },
  {
    name: "Privacy",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://eu1.prisma.sh/elandamor/the-beats-api/dev`
});
export const prisma = new Prisma();
